all, any: 833
array: 6,31,41,54,56,58,59,68,73,122,151,157,163,186,204,238,251,268,289,311,349,350,380,381,463,498,539,556,605,766,768,849,896,1014,1146,1304,1371,1381,1526,1567,1706,1822,2121
backtracking: 17,39,40,46,47,78,90,254,282,291,301,489,491,526,698,996,1088,1593,1239,1307,1681,1718,1723,1774
bfs: 79,103,116,117,126,127,130,133,173,199,200,207,210,212,269,279,297,301,314,317,339,399,407,444,505,515,529,542,637,662,743,752,785,787,803,863,909,919,934,958,959,971,987,994,1091,1110,1161,1197,1236,1254,1293,1306,1345,1368,1376,1448,1654,1778
binar352,367,374,410,715,744,774,852,875,911,1011,1055,1060,1146,1231,1272,1283,1428,1482,1552,1608,1648,1723,1802,1870,1891
bitwise operation: 29,136,137,191,201,231,268,318,338,342,371,461,473,476,491,693,698,1284,1371,1386,1442,1542,1593,1680,1681
binary search tree: 99,109,173,235,272,285,333,449,450,490,653,701,729,938,1008,1373,1382,2040
bucket:220,299
circular array: 213,1658
Deterministic Finite Automaton: 65
divide and conquer: 53,215,241,248,307,308,312,327,395,973,1000,1547
dfs: 17,79,91,93,94,95,99,100,105,106,112,113,124,129,130,133,156,200,207,210,212,230,236,241,254,261,272,297,298,301,310,329,331,333,337,364,394,399,449,463,490,529,536,543,545,549,572,637,652,653,655,662,666,671,684,687,690,694,695,743,753,778,785,787,803,827,863,889,934,947,951,959,968,975,979,987,1028,1110,1161,1236,1306,1325,1339,1340,1367,1368,1372,1373,1376,1448,1462,1522,1559,1569,1644,1676,1740,1766,1778,2049,2096
dynamic programming: 5,10,32,39,44,45,53,55,63,64,70,72,84,91,96,97,115,120,139,152,188,198,213,221,256,264,265,276,279,300,312,322,361,375,403,410,413,416,435,446,464,473,474,486,494,516,518,542,552,562,576,583,629,634,647,651,673,712,727,740,746,805,813,837,871,877,879,887,920,931,935,940,956,968,983,1000,1027,1035,1039,1048,1066,1092,1105,1130,1140,1143,1155,1216,1235,1259,1269,1277,1278,1301,1312,1314,1335,1406,1411,1458,1510,1547,1548,1594,1643,1696,1746,1774,1824,1879,1937,1947,1981
graph: 785,863,1615
greedy: 11,42,45,53,55,121,134,135,253,358,410,435,455,621,630,678,767,774,785,843,853,871,875,877,954,962,984,1014,1011,1130,1231,1353,1383,1402,1405,1419,1428,1482,1057,1520,1537,1546,1552,1567,1648,1665,1718,1746,1775,1802,1824,1851,1870,1877,2007
hashmap: 1,15,49,76,106,138,146,149,159,166,169,170,219,229,244,246,249,266,299,327,336,340,359,380,381,388,392,398,403,432,437,465,496,498,523,560,609,653,666,670,791,792,811,852,895,930,953,954,974,1000,1055,1218,1371,1386,1442,1525,1542,1546,1570,1577,1590,1615,1644,2007,2013,2034
hashset: 1,41,128,187,290,379,381,432,653,694,721,804,1239,1452,1647,1774,2061
inorder: 99,105,230,333,426
linked list: 2,21,24,25,61,83,86,109,116,117,138,146,148,382,432,445,587,705,706,1650
doubly linked list: 716
logic deduction: 444 
map: 205
math:7,9,12,50,67,149,166,168,204,223,263,268,277,279,296,319,360,384,391,462,470,621,794,836,837,952,1041,1344,1569,1610,1627,1643,1998,2119,2128
merge sort: 148,315,1574
misc:169,229(moore voting)
preorder: 105,106,113,331,437,449,545,652,666,889,971,987,1008,1028,1569
priority queue: 23,215,218,239,253,295,347,358,373,404,621,630,632,642,759,767,778,973,1229,1353,1383,1438,1439,1499,1675,1696,1834,1851,1882
queue:232,239,656,1057,1425,1438,1499,1696
range sum: 307,308,327,1314,930,1442
segment tree: 307,308,327,850
sliding window: 3,76,159,209,239,340,395,837,862,904,930,992,1004,1052,1234,1358,1371,1423,1498,1509,1537,1574,1577,1610,1658,1696,1793,1839
SQL: 176
sort: 31,56,99,148,164,179,220,252,280,315,524,539,556,581,593,L391,611,973,1300,1509,1608,1610
stack: 20,32,42,71,84,85,150,155,224,227,232,331,341,388,394,402,456,496,503,536,581,636,678,716,735,739,768,772,856,901,907,921,946,962,975,1019,1028,1047,1063,1106,1124,1130,1209,1249,1381,1541,1597,1673,1762,1776,1856,1944,1966
string: 5,6,65,151,157,165,214,408,418,443,722,824,833,929,984,1087,1520
topological sort: 207,210,269,310,329,444,1462,2115
tree: 94,100,109,112,114,116,222,235,236,285,298,333,337,339,366,426,450,515,543,549,572,652,653,687,729,919,1325,1339,1367,1372,1522,1644,1650,1676,1740,2049,2096
treemap: 716,2034
trie: 139,208,211,212,336,616,642,745
two pointers: 11,15,16,27,42,61,76,86,121,159,167,209,244,246,253,259,360,392,462,524,581,611,680,777,904,977,986,1055,1229,1248,1537,1574,1577,1658,1775,1868
union find: 128,261,305,323,684,721,778,947,952,1562,1627,1722,1970,1998,2076


## Array
- Problems:
    - print screen:68-Text Justification; 418-Sentence Screen Fitting
    - reuse previously computed value: 2121-Intervals Between Identical Elements
    - 1D array: 31-Next Permutation|556-Next Greater Element III|1643-Kth Smallest Instructions(has better solution);  41-First Missing Positive; 58-Length of Last Word; 605-Can Place Flowers; 1304-Find N Unique Integers Sum up to Zero; 1562-Find Latest Group of Size M(hard)
        - linear search: 163-Missing Ranges;
        - linear scan: 896-Monotonic Array; 1822-Sign of the Product of an Array
        - sort + linear scan: 539-Minimum Time Difference
    - 2D array: 
        - tip: in-place transformation: (289)
        - eg: 251-Flatten 2D Vector; 289-Game of Life; 463-Island Perimeter; 766-Toeplitz Matrix; 1706-Where Will the Ball Fall; 1275-Find Winner on a Tic Tac Toe Game;
            - matrix: 59-Spiral Matrix II; 311-Sparse Matrix Multiplication

## backtracking 
    - complexity: time - O(2^n) each position can be chosen or not; space - O(n)
    - tip: 
        * dedup: sort and skip same number (eg. 40-Combination Sum II; 47-Permutations II)
    - eg: 17-Letter Combinations of a Phone Number; 39-Combination Sum|40-Combination Sum II; 47-Permutations II; 78-Subsets(classic)|90-Subsets II|46-Permutations|47-Permutations II; 254-Factor Combinations; 282-Expression Add Operators; 291-Word Pattern II; 491-Increasing Subsequences; 526-Beautiful Arrangement; 996-Number of Squareful Arrays; 1239-Maximum Length of a Concatenated String with Unique Characters; 698-Partition to K Equal Sum Subsets; 1088-Confusing Number II; 1593-Split a String Into the Max Number of Unique Substrings; 1681-Minimum Incompatibility; 1307-Verbal Arithmetic Puzzle(hard); 1718-Construct the Lexicographically Largest Valid Sequence (with greedy); 1723-Find Minimum Time to Finish All Jobs(hard, with binary search); 1774-Closest Dessert Cost；465-Optimal Account Balancing (hard)
    - state compression with bitmasking: see "## Bitmasking"

## binary search
- Key words:
find, sorted
- Three templates
1. when loop ends, start + 1 = end
```
start, end = 0, len(n) - 1
while start + 1 < end: 
    mid = start + (end - start) // 2
    if nums[mid] < target:
        start = mid
    else:
        end = mid
```
2. When loop ends, start = end
```
start, end = 0, len(n)
while start < end: # when loop ends, start = end
    mid = start + (end - start) // 2
    if nums[mid] < target:
        start = mid + 1
    else:
        end = mid
```
3. when loop ends, start = end + 1
```
start, end = 0, len(n) - 1
while start <= end: 
    mid = start + (end - start) // 2
    if nums[mid] < target:
        start = mid + 1
    else:
        end = mid - 1
```
- My template:
    - strictly increasing find last one smaller than or equal to target
    ```
    start, end = 0, len(n) - 1  # use start = -1 or end = len(n) if returning -1 or len(n) is possible
    def bs(nums, start, end, target):
        if start == end:
            return start
        mid = start + (end - start + 1) // 2 # because start = mid, has to + 1 to shift to end or will be endless loop
        if nums[mid] > target: # use >, >=, <, <= based on specific case
            end = mid - 1
        else:
            start = mid
        return bs(nums, start, end, target)
    ```
    - strictly increasing find first one larger than or equal to target
    ```
    start, end = 0, len(n) - 1
    def bs(nums, start, end, target):
        if start == end:
            return start
        mid = start + (end - start) // 2 # because end = mid, don't + 1 to shift to start or will be endless loop
        if nums[mid] < target:
            start = mid + 1
        else:
            end = mid
        return bs(nums, start, end, target)
    ```
- tips
    - prevents int overflow:

        use:
        ```
        mid = start + (end - start) // 2
        ```
        not:
        ```
        mid = (start + end) // 2
        ```
- Examples: 57,911,1146(bisect), 278,374-Guess Number Higher or Lower(basic), 981-Time Based Key-Value Store(strictly increasing, find lower), 315
- problems:
    - binary search the answer: get the possible range of answer, binary search between range and see if current number can satisfy condition using greedy algorithm
        - eg: 287-Find the Duplicate Number; 410-Split Array Largest Sum|774; 778-Swim in Rising Water(graph)|875|1011|1231|1283|1300|1482; 1552-Magnetic Force Between Two Balls; 1648|1802(hard)|1870; 1891-Cutting Ribbons;1723-Find Minimum Time to Finish All Jobs(hard, with backtracking); 279-Perfect Squares; 2040-Kth Smallest Product of Two Sorted Arrays(hard)
    - multiplication/division: 29-Divide Two Integers; 367-Valid Perfect Square; 
    - arrays: 
        - find target:
            eg. 34-Find First and Last Position of Element in Sorted Array; 35-Search Insert Position; 162-Find Peak Element (unsorted); 825-Friends Of Appropriate Ages; 1060-Missing Element in Sorted Array
            - with edge cases: 744-Find Smallest Letter Greater Than Target
        - rotated arrays:
            - tip: when there are duplicates, add duplicates removal steps (154, 81)
            - eg. 153-Find Minimum in Rotated Sorted Array|154. Find Minimum in Rotated Sorted Array II|33-Search in Rotated Sorted Array|81-Search in Rotated Sorted Array II; 
        - merge arrays:
            - eg. 4-Median of Two Sorted Arrays
    - merge intervals: see "## sweep line"

## Bitwise Operation
- AND
    - tricks:
        - x & 1: get the rightmost bit
        - x & (x - 1): remove rightmost 1
        - x & (x - 1) == 0: tests if x is the power of two
    - eg. 190-Reverse Bits; 191-Number of 1 Bits; 201-Bitwise AND of Numbers Range; 231-Power of Two; 342-Power of Four; 338-Counting Bits
- XOR
    - definition - same: 0, different: 1
    - problems:
        - a number XOR itself equals 0: 136-Single Number; 137-Single Number II; 268-Missing Number
        - Subarray containing chars with certain conditions
            - tips: memoize the state of all prefixes in a hashmap, compute state using XOR
            - eg: 1371(even/odd),1542
        - Pure XOR: 1442,
        - Addition: 371-Sum of Two Integers; 1680-Concatenation of Consecutive Binary Numbers
        - Bit difference/similarity: 461-Hamming Distance; 693-Binary Number with Alternating Bits
        - flip the bit: 476-Number Complement
- Bit shift
    - multiplication: 29-Divide Two Integers


## Bitmasking
- problems:
    - compression/serialization:
        - eg: 187-Repeated DNA Sequences; 287-Find the Duplicate Number; 318-Maximum Product of Word Lengths; 1284-Minimum Number of Flips to Convert Binary Matrix to Zero Matrix (bfs)
    - enumeration (can be solved using backtracking):
        - eg: 90-Subsets II; 464-Can I Win; 491-Increasing Subsequences; 526-Beautiful Arrangement; 698-Partition to K Equal Sum Subsets; 1386-Cinema Seat Allocation; 1593-Split a String Into the Max Number of Unique Substrings; 1681-Minimum Incompatibility

## BFS
- key word: shorted path (eg. 1345); 
- algorithm:
    elements: queue, visited hashset; 
    steps: while q, if q popped is target, finish, if not, add popped item's neighbors to the q; optimization: visited can be eliminated if allowed to change memory (mark on original data)
- problems:
    - all shortest paths: 301
    - 1D (array): 1654-Minimum Jumps to Reach Home; 279-Perfect Squares
    - 2D shortest paths: 505-The Maze II;542-01 Matrix; 317-Shortest Distance from All Buildings(hard); 909-Snakes and Ladders(1d conversion); 994-Rotting Oranges; 1091-Shortest Path in Binary Matrix; 1284-Minimum Number of Flips to Convert Binary Matrix to Zero Matrix (hard); 1293-Shortest Path in a Grid with Obstacles Elimination (hard)
    - String: 752-Open the Lock
    - Dijkstra's Algorithm:
        - key words: minimal cost of paths (unlike regular shortest path where cost is always 1, each connection can have various cost)
        - caveat: visited.add() happens at node pop, not node push, since shortest cost is found when node with the smallest cost pops, when pushing a node we could push one with cost larger than smallest cost
        - intuition: similar as bfs, difference is that instead of using a queue and always pop left (which is by default the minimal cost), use a heap to store tuple (total_cost, node) to always pop the smallest cost; also need an array/map to memoize smallest cost to each node; IMPORTANT - the use of heap guarantees that a node with smallest price route always popped first (no matter how many stops it takes to arrive at it) 
        - eg. 743-Network Delay Time (classic); 505-The Maze II; 787-Cheapest Flights Within K Stops; 407-Trapping Rain Water II (implicit); 656-Coin Path(hard, TLE); 1368-Minimum Cost to Make at Least One Valid Path in a Grid(have better solutions using dfs)
    - tree traversal: see "## Tree"
    - construct sequence with topological sort (see "## Topological Sort")
    - bidrectional dfs
        - purpose: speeding up bfs
        - patterns: use two sets to store current nodes visited from beginning and end layers; for each round of bfs, search from the set with fewer nodes
        - 127-Word Ladder|126-Word Ladder II(hard); 1197-Minimum Knight Moves; 1345-Jump Game IV
    - not only min distance, but need routes with min distance:
        - eg: 126-Word Ladder II

## Cache
- tip: cache previous result to save time
- eg: 418-Sentence Screen Fitting

## Counter
    eg: 900-RLE Iterator; 1419-Minimum Number of Frogs Croaking

## Divide and Conquer
- problems:
    - find subarrays/string with conditions:
        - eg: 53-Maximum Subarray; 248-Strobogrammatic Number III

## Data Structure Implementation 
- summary: implement a data structure with required APIs and targeted complexity
- problems: 
    - hashset/hashmap implementation:
        - modulo with a list of linkedlists/bst
        - eg: 705-Design HashSet, 706-Design HashMap
    - hashmap: 244-Shortest Word Distance II; 380-Insert Delete GetRandom O(1)|381-Insert Delete GetRandom O(1) - Duplicates allowed((O(1) removal at index i by switching elements))
    - hashmap / doubly linked list: 146-LRU Cache; 432-All O`one Data Structure,460,1146,1381
    - array O(1): 380-Insert Delete GetRandom O(1)|381-Insert Delete GetRandom O(1) - Duplicates allowed((O(1) removal at index i by switching elements))
    - stack: 
        155-Min Stack
    - heap: 295
    - treemap(sorted dict): 2034-Stock Price Fluctuation
    - Fenwick tree / segment tree: 
        - key word: range sum/min/max
        - eg. 307-Range Sum Query - Mutable; 308,327
- tips:
    use hashmap to achieve O(1) retrieval of a key
    use hashmap and doubly linked list to achieve retrieving min/max in O(1) eg:(LRU/LFU)146,432,460,716-Max Stack
    use Fenwick tree or Segment tree to solve range sum/max/min problem

## DFS - don't forget to reset visited back when all the branched dfs does not succeed.
- recursive (in-order)
```
    def dfs(node):
        if not node:
            return
        dfs(node.left)
        print(node.val)
        dfs(node.right)
```
- iterative (in-order)
```
    stack = []
    while stack or node:
        if node:
            stack.append(node)
            node = node.left
        else:
            node = stack.pop()
            print(node.val)
            node = node.right
```
or 
```
    stack = []
    while stack or node:
        while node:
            stack.append(node)
            node = node.left
        node = stack.pop()
        print(node.val)
        node = node.right
```
- Inorder Morris*: O(n), O(1); eg.99
```
    node = root        
    while node:
        if node.left:
            temp = node.left
            while temp.right and temp.right != node:
                temp = temp.right
            if not temp.right: # when looking for prev, attach temp.right to node
                temp.right, node = node, node.left
                continue
            # when traversal, detach temp.right from node
            temp.right = None
        print(node.val)
        node = node.right

```
- Complexity: 
    - Time: O(n) - one visit each node
    - Space: O(n) - n stacks for skewed tree
- example: 
    - 93-Restore IP Addresses; 230, 254-Factor Combinations; 337; 690-Employee Importance; 778-Swim in Rising Water
    - nested list: 339-Nested List Weight Sum(also bfs); 341-Flatten Nested List Iterator(stack); 364-Nested List Weight Sum II

## 2D DFS/BFS
- problems:
    - map hidden graph
        - eg: 489-Robot Room Cleaner; 1778-Shortest Path in a Hidden Grid; 1810-Minimum Path Cost in a Hidden Grid
    - find contiguous regions
        - eg: 130-Surrounded Regions; 200-Number of Islands | 694-Number of Distinct Islands | 1254-Number of Closed Islands | 934-Shortest Bridge (bfs + dfs); 463-Island Perimeter; 959-Regions Cut By Slashes (need pixelating); 803-Bricks Falling When Hit (hard); 827-Making A Large Island(mark by index); 2061-Number of Spaces Cleaning Robot Cleaned(with state)
    - min cost: see ## BFS
    - operation chaining:
        - eg: 399-Evaluate Division
    - other: 1559-Detect Cycles in 2D Grid; 1766-Tree of Coprimes (hard)

## Dynamic programming -
backtracking with memoization; steps: build dp memory, define what dp[i] represents, find update function(s)
space can be optimized to O(1) if only need to track constant time of variables for each update
- Top down (depth-first-search): recursion using memoization
- Bottom up: loop using memoization (calculate those won't change first, eg.1143, 1340) - look at the transformation formula from the top-down solution to figure out what needs to be calculated first in the loop. Can use the subproblem size as the outer loop if dp(i, j) need dp(i + 1, j - 1) (eg.312，375, 486, 877, 1312)
- problems:
    - dp[i] depends on dp[i-1]: 
        - eg. 53-Maximum Subarray; 70-Climbing Stairs; 198-House Robber|213. House Robber II|740-Delete and Earn; 256-Paint House|265-Paint House II; 152-Maximum Product Subarray(min/max); 276-Paint Fence(a hard medium); 413-Arithmetic Slices; 91-Decode Ways;139-Word Break|140-Word Break II; 647-Palindromic Substrings; 837-New 21 Game; 931-Minimum Falling Path Sum;
    - dp[i] depends on k previous cases dp[j] where j < i:
        - eg: 45-Jump Game II; 651-4 Keys Keyboard; 935-Knight Dialer; 1218-Longest Arithmetic Subsequence of Given Difference
    - dp[i] depends on dp[j] where j in [1...i]:
        - eg. 64-Minimum Path Sum; 96-Unique Binary Search Trees; 542-01 Matrix; 221-Maximal Square|85-Maximal Rectangle(hard)|1277-Count Square Submatrices with All Ones; 446-Arithmetic Slices II - Subsequence|1027-Longest Arithmetic Subsequence;673-Number of Longest Increasing Subsequence; 931-Minimum Falling Path Sum | 1937-Maximum Number of Points with Cost; (revisit above examples!) 940. Distinct Subsequences II; 1105-Filling Bookcase Shelves; 1235-Maximum Profit in Job Scheduling; 1259-Handshakes That Don't Cross
    - dp[i][j] depends on dp[i+1][j-1]:
        - tip: use subproblem size (diff between i and j) as the outer loop
        - eg: 312-Burst Balloons(hard)|1039-Minimum Score Triangulation of Polygon|1130-Minimum Cost Tree From Leaf Values; 375-Guess Number Higher or Lower II; 486, 516-Longest Palindromic Subsequence, 877, 1246-Palindrome Removal(hard); 1312; 1959-Minimum Total Space Wasted With K Resizing Operations
    - intervals: sequence needs to be divided into k distinct intervals
        - key words: split array
        - dp[i][k] depends on dp[j][k-1] where j = [1...i]
        - eg: 410-Split Array Largest Sum; 813-Largest Sum of Averages; 1278-Palindrome Partitioning III; 1335-Minimum Difficulty of a Job Schedule
    - two sequences:
        - key words: longeest common subsequences, shortest common superseequence, edit distance, ...
        - tip: dp[i][j] result at s1[:i1+1] and s2[:i2+1]
        - eg.
            - longest common subsequences/shortest common superseequence: 97-Interleaving String; 115-Distinct Subsequences; 727. Minimum Window Subsequence; 1143-Longest Common Subsequence; 1092-Shortest Common Supersequence
            - sequence matching: 10-Regular Expression Matching; 44-Wildcard Matching
            - edit distance: 72-Edit Distance; 583-Delete Operation for Two Strings|712. Minimum ASCII Delete Sum for Two Strings; 1216-Valid Palindrome III|1312. Minimum Insertion Steps to Make a String Palindrome; 1548-The Most Similar Path in a Graph
            - palindrome: 5-Longest Palindromic Substring; 516-Longest Palindromic Subsequence, 1216-Valid Palindrome III|1312. Minimum Insertion Steps to Make a String Palindrome
        - advanced: ask to track path
            - tip: can store min/max in dp first, then trace the path
            - eg: 727-Minimum Window Subsequence; 1092-Shortest Common Supersequence
    - knapsack:
        - dp[i] depends on dp[i-k] where k is the item cost/size in an array of n items
        - keyword: combine numbers in array to reach a target
        - memo: dp[_sum][i]
        - tip: for 0/1 knapsack: decrease i to avoid over counting; for 0/n knapsack: increase i to allow counting more than 1 time
        - problems:
            - 0/1 knapsack: each element can be used 0 or 1 time
                - eg: 416-Partition Equal Subset Sum|956-Tallest Billboard(hard, need max);474-Ones and Zeroes(two bags)|879-Profitable Schemes; 871-Minimum Number of Refueling Stops(hard, todo); 1981-Minimize the Difference Between Target and Chosen Elements;805-Split Array With Same Average;
            - 0/n knapsack: each element can be used 0 or infinite amount of times
                - eg: 039-Combination Sum; 139-Word Break; 264-Ugly Number II; 322-Coin Change|691-Stickers to Spell Word(hard, with state compression)|1125-Smallest Sufficient Team; 983-Minimum Cost For Tickets; 1449-Form Largest Integer With Digits That Add up to Target
            - pos/neg knapsack: 494-Target Sum; 956-Tallest Billboard; 1049-Last Stone Weight II
            - two bags: 474-Ones and Zeroes(two bags)|879-Profitable Schemes; 956-Tallest Billboard(can be resolved with one bag)
        - eg: 630-Course Schedule III; 1774-Closest Dessert Cost
    - state compression:
        - bitmasking:
            - algorithm: use bits to represent the state of the candidate
                - initialization: (1 << m) - 1   (where m is the candidate size)
                - check each candidate's availability: bitmask & (1 << j) for j in range(M)
                - set candidate's availability to 0 once picked: bitmask ^ (1 << j)
            - eg: 691-Stickers to Spell Word(0/n); 1947-Maximum Compatibility Score Sum(classic, m to m)|1879-Minimum XOR Sum of Two Arrays|1066-Campus Bikes II(n to m); 1125-Smallest Sufficient Team(0/1);
    - 2D m*n:
        - eg: 63-Unique Paths II; 120-Triangle; 361-Bomb Enemy; 576-Out of Boundary Paths; 931-Minimum Falling Path Sum; 1301-Number of Paths with Max Score; 1594-Maximum Non Negative Product in a Matrix; 1643-Kth Smallest Instructions
    - length in matrix: 562
    - reachable problem: 45,55
    - merge: divide and conquer: 241
        - calculation among adjacent items: 312, 1039, 1547, 1000-Minimum Cost to Merge Stones(hard)
            - tip: when bottom-up, use subproblem size as the outer loop
    - game theory: 
        - tip: max opponent, min your self
        - eg. 375-Guess Number Higher or Lower II|887-Super Egg Drop(hard); 486-Predict the Winner|877-Stone Game|1140-Stone Game II|1406-Stone Game III|1510-Stone Game IV
    - string subsequence with min/max cost: 97,516,583,1035,1092,1143,1458
        - edit-distance: 72,583,712,1312,1548-The Most Similar Path in a Graph
        - subsequence combinations: 115-Distinct Subsequences
    - string/serialized list or set as memoization key: 464-Can I Win; 1048-Longest String Chain
    - number of ways:
        - tip: can use dp[i] to store number of ways when ending at element i, then the result is sum(dp) (eg.940)
        - eg: 115-Distinct Subsequences; 1155-Number of Dice Rolls With Target Sum; 279-Perfect Squares; 1269-Number of Ways to Stay in the Same Place After Some Steps; 276-Paint Fence(a hard medium); 552-Student Attendance Record II(hard); 879-Profitable Schemes(hard); 940-Distinct Subsequences II (hard)
        - combination/permutation: 
            - tip: 分类讨论
            - 629-K Inverse Pairs Array; 634-Find the Derangement of An Array(hard); 920-Number of Music Playlists(hard); 1411-Number of Ways to Paint N × 3 Grid(hard)
    - subarray max/min: 
        - can also use greedy
        - eg: 53-Maximum Subarray; 1746-Maximum Subarray Sum After One Operation
    - subsequence:
        - eg: 300-Longest Increasing Subsequence
    - others:
        - eg: 188-Best Time to Buy and Sell Stock IV; 968-Binary Tree Cameras;

## Graph
- Complexity
    - time: O(V + E) V - number of nodes; E: number of edges (each node and each edge is traversed exactly once)
    - space: O(V + E) for the adjacency graph (V keys, one value for each E)
- Algorithms: DFS and BFS
- Problems:
    - acyclic graph: 
        - eg. 1376-Time Needed to Inform All Employees; 1377-Frog Position After T Seconds
    - detect cycle:
        - eg: 261-Graph Valid Tree; 684-Redundant Connection;
    - eg: 785-Is Graph Bipartite?;
    - minimum cost path: Dijkstra Algorithm (see "## BFS")
    - others: 1615-Maximal Network Rank

## Greedy -
- instinct: 
Pick the locally optimal move at each step, and that will lead to the globally optimal solution.
Iterate over the array and update at each step the standard set for such problems: 1.current element 2.current local maximum sum (at this given point) 3.global maximum sum seen so far.
    - eg: 1402,1520,1665
- problems:
    - general(regional min/max): 11-Container With Most Water|42-Trapping Rain Water; 121-Best Time to Buy and Sell Stock|1014-Best Sightseeing Pair|1937-Maximum_Number_of_Points_with_Cost; 134-Gas Station; 135-Candy;
    - greedy with sort: 853-Car Fleet; 1775-Equal Sum Arrays With Minimum Number of Operations; 1537-Get the Maximum Score; 954-Array of Doubled Pairs|2007-Find Original Array From Doubled Array; 1877-Minimize Maximum Pair Sum in Array
    - violate rule first, greedily remediate after: 
        - tip: using heap to greedily pick the largest item to remediate
        - eg. 45-Jump Game II; 871-Minimum Number of Refueling Stops
    - maximum subarray: 53-Maximum Subarray; 1746. Maximum Subarray Sum After One Operation
    - shortest subarray: 1546-Maximum Number of Non-Overlapping Subarrays With Sum Equals Target
    - minimum state change: 1824-Minimum Sideway Jumps
    - game theory: 464-Can I Win; 486-Predict the Winner; 843-Guess the Word; 877-Stone Game | 1140-Stone Game II|1406-Stone Game III|1510-Stone Game IV
    - rearrange with k stride: 
        - tip: greedily fill chars with more counts first, can also be solved using priority queue
        - eg. 358-Rearrange String k Distance Apart(hard, classic); 621-Task Scheduler; 767-Reorganize-String|984-String Without AAA or BBB|1405-Longest Happy String

## Hashmap
    - problems:
        - sums:
            - eg: 1-Two Sum|170-Two Sum III - Data structure design
        - index to value:
            -eg: 244-Shortest Word Distance II; 498-Diagonal Traverse(diagonal indexes sum); 953-Verifying an Alien Dictionary; 1570-Dot Product of Two Sparse Vectors;
        - value to index:
            -eg. 219-Contains Duplicate II; 670-Maximum Swap; 825-Friends Of Appropriate Ages
        - list dict:
            - eg. 1386-Cinema Seat Allocation
        - counter:
            - eg: 266-Palindrome Permutation; 340-Longest Substring with At Most K Distinct Characters; 791-Custom Sort String; 811-Subdomain Visit Count; 2013-Detect Squares;
        - dedup:
            - eg: 609-Find Duplicate File in System
        - value to subarray/subsequence length:
            - eg: 1218-Longest Arithmetic Subsequence of Given Difference
        - numbers:
            - eg. 166-Fraction to Recurring Decimal; 388-Longest Absolute File Path
        - strings:
            - eg: 49-Group Anagrams; 290|291-Word Pattern II; 392-Is_Subsequence
        - coordinates:
            - eg: 149-Max Points on a Line
        - arrays:
            - eg: 249-Group Shifted Strings
        - prefix sum (see "## Prefix sum")

## Hashset
- problems:
    - set operation: 1452-People Whose List of Favorite Companies Is Not a Subset of Another List
    - dedup: 187-Repeated DNA Sequences; 290-Word Pattern; 379-Design Phone Directory; 1647-Minimum Deletions to Make Character Frequencies Unique; 804-Unique Morse Code Words;
    - find pair: 41-First Missing Positive; 653. Two Sum IV - Input is a BST
    - Storing states: 1774-Closest Dessert Cost; 2061-Number of Spaces Cleaning Robot Cleaned
    - consecutive numbers: 128-Longest Consecutive Sequence

## Heap - 
heapify time complexity: O(n), heap push/pop time complexity: O(logn)
- eg:
    - median: 295

## LinkedList
- tips:
    use dummy node to avoid checking edgecases 146-LRU Cache, 116/117
- problems:
    - add/remove: 83-Remove Duplicates from Sorted List
    - find out the size of a circular linkedlist or the middle of the linkedlist
        - algorithm: fast and slow pointers
        - eg: 109-Convert Sorted List to Binary Search Tree; 143-Reorder List
    - reverse a linkedlist:
        - eg: 143-Reorder List; 25-Reverse Nodes in k-Group
    - link cycle
        - two pointers: 61-Rotate List
    - connect:
        - 116|117-Populating Next Right Pointers in Each Node I/II

## Fenwick Tree (or binary index tree):
- used to solve numerous RANGE QUERY problems like finding minimum, maximum, sum, greatest common divisor, least common denominator in array in logarithmic time.
- eg: 307,308(2D),327(prefix-sum)
- can also use "Segment tree" to solve with more space

## Math
- permutation and combination
    - formula: P(n, r) = n! / (n - r)!   C(n, r) = n! / (r! * (n - r)!)
    - eg. 1569; 1643-Kth Smallest Instructions
- Gauss sum:
    - n + (n + 1) + ... + (n + k) = (n + n + k) * (k + 1) // 2
    - eg. 268-Missing Number; 1648, 1802
- Sampling:
    - reservoir sampling: sampling in large/dynamic-size arrays with O(1) space
        - eg: 382-Linked List Random Node; 398-Random Pick Index
    - Implement RandM() using RandN()
        - 470-Implement Rand10() Using Rand7()
    - sampling with weight:
        - algorithm: prefix-sum with binary search
        - eg: 528-Random Pick with Weight (with prefix-sum); 497-Random Point in Non-overlapping Rectangles (with binary search)
- Convex Hull:
    - algorithms: Jarvis Algorithm, Graham Scan, Monotone Chain
    - eg: 587-Erect the Fence
- Math deduction:
    - eg. 277-Find the Celebrity; 319-Bulb Switcher; 462-Minimum Moves to Equal Array Elements II; 877-Stone Game
    - matrix flip: 2128-Remove All Ones With Row and Column Flips
- Bachet's conjecture:
    - eg: 279-Perfect Squares
- Statistics:
    - median: 462-Minimum Moves to Equal Array Elements II
- Probability:
    - eg: 384-Shuffle an Array; 837-New 21 Game
- Factorization:
    - eg: 952-Largest Component Size by Common Factor; 1998-GCD Sort of an Array
- Primes:
    - eg: 1627-Graph Connectivity With Threshold; 204-Count Primes|1998-GCD Sort of an Array(Sieve of Eratosthenes)
- Trignometry:
    - radian
        - def: radians (0 degree - 0, 90 - 1.57, 180 - pi, 270 - -1.57, 360 - 0); radian of a line (defined by two points (a, b)) to positive x axis: math.atan2(b[1] - a[1], b[0] - a[0])
        - eg: 1610-Maximum Number of Visible Points
- Algebra:
    - additioon: 67-Add Binary
    - power: 50-Pow(x, n)
    - division:
        - eg. 7-Reverse Integer; 9-Palindrome Number; 263-Ugly Number;
        - long division: 166-Fraction to Recurring Decimal
    - mod:
        - eg: 2119-A Number After a Double Reversal
    - line formula:
        - eg: 149-Max Points on a Line
    - quadratic formula:
        - eg: 360-Sort Transformed Array
- Coordinates:
    - 223-Rectangle Area
- Optimal：
    - eg. 296-Best Meeting Point

## Pre-computing:
- problems:
    - Calculation with certain restrictions: precompute partial results
        - eg: 238-Product of Array Except Self
    - Saving compute time
        - eg: 303-Range Sum Query - Immutable

## Prefix sum:
- key words: sum of subarray 
- tip: usually solved with O(n) time using hashmap 
- Problems:
    - prefix-sum
        - eg.303-Range Sum Query - Immutable|304-Range Sum Query 2D - Immutable; 560-Subarray Sum Equals K,325-Maximum Size Subarray Sum Equals k; 930,974|1590(division),1371-Find the Longest Substring Containing Vowels in Even Counts;1442,437(tree version), 1124, 528-Random Pick with Weight; 1248-Count Number of Nice Subarrays; 1525-Number of Good Ways to Split a String; 1546-Maximum Number of Non-Overlapping Subarrays With Sum Equals Target;
    - prefix-sum % k as key:
        - eg: 523-Continuous Subarray Sum


## Priority Queue (Heap):
- tip: stores tuples in queues, a tuple is comprised of number (a group of numbers) needs to be sorted and the information need to pass when that number is popped from the heap (eg.373)
- key words: sort
- problems:
    - queue with conditions: 1882-Process Tasks Using Servers
    - sorting:
        - eg: 23-Merge k Sorted Lists; 373-Find K Pairs with Smallest Sums|1439-Find the Kth Smallest Sum of a Matrix With Sorted Rows; 632-Smallest Range Covering Elements from K Lists; 642-Design Search Autocomplete System; 778-Swim in Rising Water; 1675-Minimize Deviation in Array
    - greedy:
        - eg: 253-Meeting Rooms II; 1353-Maximum Number of Events That Can Be Attended; 502-IPO, 630-Course Schedule III(greedy * 2)|1383-Maximum Performance of a Team; 767-Reorganize String|358-Rearrange String k Distance Apart(hard)|621-Task Scheduler; 1057-Campus Bikes; 1499-Max Value of Equation; 1851-Minimum Interval to Include Each Query;
    - Dijkstra's Algorithm (see "## BFS")

## Sliding window -
- problems:
    - fixed length sliding window:
        - eg. 1052; 1509-Minimum Difference Between Largest and Smallest Value in Three Moves
    - substring that has given numbers of certain characters: 
        - algorithm: move right pointer to right until satisfies condition, then move left pointer to right to tighten window until condition not satisfied
        - eg. 3-Longest Substring Without Repeating Characters | 159-Longest Substring with At Most Two Distinct Characters | 340-Longest Substring with At Most K Distinct Characters | 992-Subarrays with K Different Integers | 395-Longest Substring with At Least K Repeating Characters; 76,1234; similar:904;1004-Max Consecutive Ones III;1248-Count Number of Nice Subarrays (loose end); 1358-Number of Substrings Containing All Three Characters; 1371-Find the Longest Substring Containing Vowels in Even Counts; 1438-Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit(hard); 1839-Longest Substring Of All Vowels in Order; 1658-Minimum Operations to Reduce X to Zero
    - subarray sum with a target: sliding window with prefix-sum / two pointers
        - eg: 209-Minimum Size Subarray Sum; 713-Subarray Product Less Than K; 930-Binary Subarrays With Sum; 1658-Minimum Operations to Reduce X to Zero
    - use a sliding window to keep the running sum of last n items: 837-New 21 Game
    - largest size of subsequence with in target diff: 
        - tip: sort first
        - eg. 1610-Maximum Number of Visible Points(hard, 2D)
    - monotonic queue: 
        - intuition: keep track of the max/min in window when window size is large; can be more effiecient than the solution using a priority queue which has a complexity of O(nlogk) where k is the window size (eg.1499).
        - algorithm: 
            - after popleft() indexes out of range, q[0] is the next smallest/largest in eligible window
            - after pop() indexes i with nums[i] >(<) nums[curr_i], append curr_i to q as next candidate.
        - complexity: O(n), O(n) - each item queued and popped exactly once
        - eg. 239-Sliding Window Maximum; 656. Coin Path(hard); 862-Shortest Subarray with Sum at Least K; 1425-Constrained Subsequence Sum; 1438-Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit(two queues); 1499-Max Value of Equation; 1696-Jump Game VI

## Sorting
- quick sort 
    - algorithm: (classic eg.215)
        1. find a random pivot
        2. put the pivot in its sorted position (elements to its left are smaller and elements to its right are greater)
        3. recursively sort the left and the right partition
    - Complexity:
        O(nlogn) on average; O(n^2) worst case
        O(1) space (in-place sorting)
    - variations:
        quick select: 
            - key word: get largest/smallest k
            - complexity: O(n) on average since only sorting one partition; O(n^2) worst case
            - eg.215-Kth_Largest_Element_in_an_Array, 973-K Closest Points to Origin
- merge sort: 
    - algorithm:
        1. recursively call merge_sort on left half, then on right half
        2. merge left half and right half
    - Complexity:
        time: O(nlogn)
        space: O(n) - number of nodes in the recursion tree, can be O(1) if using iterative method
    - Examples: 148-Sort List(LinkedList); 315-Count of Smaller Numbers After Self(hard)
- *sort an almost sorted array where two elements are swapped
    - Examples: 99
- wiggle sort
    - Example: 280-Wiggle Sort
- bucket sort
    - eg. 164, 220-Contains Duplicate III
- custom sort
    - eg: 179-Largest_Number
- sorting string:
    - eg: 953-Verifying an Alien Dictionary
- python SortedList:
    - eg. 220-Contains Duplicate III
- next larger element:
    - eg.31-Next Permutation; 556-Next Greater Element III

## Stack
- problems:
    - straight forward stack:
        - eg: 071-Simplify_Path; 388-Longest Absolute File Path; 636-Exclusive Time of Functions; 716-Max Stack(hard); 735-Asteroid Collision; 1047-Remove All Adjacent Duplicates In String; 1209-Remove All Adjacent Duplicates in String II;
    - parenthesis: 
        - eg. 20-Valid Parentheses; 32, 394-Decode String; 536-Construct Binary Tree from String; 678, 856-Score of Parentheses; 921-Minimum Add to Make Parentheses Valid(basic); 1087-Brace Expansion(no stack); 1249, 1541; 772-Basic Calculator III
        - can also use two passes: 32
    - math evaluation:
        - tip: can use either a stack or a recursive solution
        - eg. 150-Evaluate Reverse Polish Notation; 224-Basic Calculator|227-Basic Calculator II|772-Basic Calculator III; 1106-Parsing A Boolean Expression
    - dfs:
        - graph traversal: see "## DFS"
        - other: 341-Flatten Nested List Iterator 
    - monotonically increasing/decreasing stack
        - comparison:
            - eg: 1762-Buildings With an Ocean View(easy); 496,503-Next Greater Element I/II|1944-Number of Visible People in a Queue|1966-Binary Searchable Numbers in an Unsorted Array; 1063-Number of Valid Subarrays; 739-Daily Temperatures; 901-Online Stock Span; 456-132 Pattern; 1019-Next Greater Node In Linked List; 1130-Minimum Cost Tree From Leaf Values; 
        - smallest/largest number formed by subsequence:
            -eg. 1673-Find the Most Competitive Subsequence; 402-Remove K Digits
        - window max/min (with monotonically increasing/decreasing stack)
            - intuition: it is very useful to get "next bigger item", "next smaller item", "previous bigger item", "previous smaller item" and therefore "window max" and "window min"
            - eg: 42-Trapping Rain Water(11); 84-Largest Rectangle in Histogram(hard)|85-Maximal Rectangle; 768-Max Chunks To Make Sorted II; 907-Sum of Subarray Minimums; 1856-Maximum Subarray Min-Product(similar:907); 962-Maximum Width Ramp|1124-Longest Well-Performing Interval
        - collision: 1776-Car Fleet II
            

## String:
    - tip: add dummy value at the end to simplify processing (eg. 443, calculator problems)
    - problems:
        - string manipulation: 
            - tips: use reversed string to avoid index shift (833)
            - eg: 6-Zigzag Conversion; 824-Goat Latin; 833-Find And Replace in String
        - string parsing:
            65-Valid Number; Calculator problems(see "## Stack"); 408-Valid Word Abbreviation
        - compression:
            - eg. 443-String Compression
        - Manchester:
            - eg. 5-Longest Palindromic Substring
        - KMP:
            - eg. 214-Shortest Palindrome

## Sweep Lines:
- Key words:
intervals
- Clarification Questions: 
Q: Are intervals mutually exclusive? A: Yes
- Algorithm pattern: 
    - Sort and scan 
    - priority queue/greedy 
    - binary search 
- Data structures:
- Complexity:
O(n), O(n)
- Variations: 
    - streaming intervals (can usually solve using bisect), eg: 352-Data Stream as Disjoint Intervals; 715. Range Module; 729, 731, 732, 57
    - greedy with priority queue: 759-Employee Free Time; 1353-Maximum Number of Events That Can Be Attended; 1834-Single-Threaded CPU
- Examples:
eg: 56, 57, 218, 252, 253-Meeting Rooms II, 435, 452, 616-Add Bold Tag in String; 759-Employee Free Time; 986-Interval List Intersections, 1229-Meeting Scheduler, 1272-Remove Interval, 1288, Lint391; hard-352, 391(2D), 759, 850(2D)

## Topological Sort:
    - algorithm: 
        1. build node graph and increase indegrees
        2. add nodes with indegrees == 0 to queue
        3. while q, pop node and bfs search neighbors of nodes, decrease their indegrees by 1, if indegree turns to 0, append to q
    - key words: construct sequence
    - eg: 207-Course Schedule | 210. Course Schedule II | 1462-Course Schedule IV; 310-Minimum Height Trees; 444-Sequence Reconstruction; 269-Alien Dictionary(hard); 2115-Find All Possible Recipes from Given Supplies

## Two pointers:
- problems:
    - array: 
        - eg: 27-Remove Element; 244. Shortest Word Distance II; 360-Sort Transformed Array; 462-Minimum Moves to Equal Array Elements II; 977-Squares of a Sorted Array;
        - n sums (with sort): 15-3Sum; 16-3Sum Closest; 611-Valid Triangle Number; 653. Two Sum IV - Input is a BST; 777-Swap Adjacent in LR String;
    - palindrom: 680-Valid Palindrome II; 246-Strobogrammatic Number
    - two sequences: 392-Is_Subsequence; 1537-Get the Maximum Score; 1868-Product of Two Run-Length Encoded Arrays
    - sliding window (see "## sliding window")
    - linked list cycle (see "## Linked List")

## Tree - Recursion can usually be used. 
- If using dfs, has to decide which to use: in-order traversal (aka. dfs), post-order traversal (549,1740), and pre-order traversal (298, search tree). Time complexity is O(n): every node is visited once. Space complexity is O(n) in worst case and O(log(n)) in average case: The extra space comes from implicit stack space due to recursion. For a skewed binary tree, the recursion could go up to n levels deep. If asks for a balanced tree, the space complexity is O(logn) (eg.109)
If using bfs, usually uses a FIFO queue to store nodes to be visited. 
- Problems:
    - dfs:
        - pre-order: 95-Unique Binary Search Trees II(hard); 100-Same Tree; 114-Flatten Binary Tree to Linked List(recursive/iterative); 112-Path Sum; 156-Binary Tree Upside Down; 297-Serialize and Deserialize Binary Tree; 449. Serialize and Deserialize BST; 536-Construct Binary Tree from String; 545-Boundary of Binary Tree; 572-Subtree of Another Tree|1367-Linked List in Binary Tree; 652-Find Duplicate Subtrees; 655-Print Binary Tree; 662-Maximum Width of Binary Tree; 671-Second Minimum Node In a Binary Tree; 687-Longest Univalue Path; 951-Flip Equivalent Binary Trees; 968. Binary Tree Cameras(with dp); 1008-Construct Binary Search Tree from Preorder Traversal; 1110-Delete Nodes And Return Forest; 1325-Delete Leaves With a Given Value; 1339-Maximum Product of Splitted Binary Tree; 1372-Longest ZigZag Path in a Binary Tree; 1448-Count Good Nodes in Binary Tree 2049-Count Nodes With the Highest Score; 2096-Step-By-Step Directions From a Binary Tree Node to Another;
        - in-order traversal: 
            - tip: inorder traversal of BST yields a sorted list
            - eg. 94-Binary Tree Inorder Traversal; 285-Inorder Successor in BST; 272-Closest Binary Search Tree Value II(hard); 366-Find Leaves of Binary Tree; 426-Convert Binary Search Tree to Sorted Doubly Linked List;
        - post-order traversal: 
            - 124-Binary Tree Maximum Path Sum; 543-Diameter of Binary Tree; 549-Binary Tree Longest Consecutive Sequence II; 652-Find Duplicate Subtrees; 979-Distribute Coins in Binary Tree;
    - traversal combinations: 105-Construct Binary Tree from Preorder and Inorder Traversal; 106-Construct Binary Tree from Inorder and Postorder Traversal; 889-Construct Binary Tree from Preorder and Postorder Traversal
    - BST(Binary Search Tree): 
        - a node needs to be larger than the largest node in its left subtree and smaller than the smallest node in its right subtree (eg.333, 1373)
        - tip: inorder traversal yields a sorted list
        - eg. 95-Unique Binary Search Trees II(hard); 109-Convert Sorted List to Binary Search Tree; 173-Binary Search Tree Iterator(iterative); 235-Lowest Common Ancestor of a Binary Search Tree; 285-Inorder Successor in BST(classic); 272-Closest Binary Search Tree Value II(hard); *333-Largest BST Subtree; 653-Two Sum IV - Input is a BST; 938. Range Sum of BST(easy); 450-Delete Node in a BST; 701-Insert into a Binary Search Tree; 1008-Construct Binary Search Tree from Preorder Traversal; 1373-Maximum Sum BST in Binary Tree; 1382-Balance a Binary Search Tree;
    - Breath-first search(BFS): 
        - eg: 199-Binary Tree Right Side View; 297-Serialize and Deserialize Binary Tree; 314-Binary Tree Vertical Order Traversal; 339-Nested List Weight Sum; 515-Find Largest Value in Each Tree Row; 662-Maximum Width of Binary Tree; 1110-Delete Nodes And Return Forest;
        - complete binary tree
            - eg: 919-Complete Binary Tree Inserter; 958-Check Completeness of a Binary Tree
    - Tree serialization: 
        - tip: can either use pre or post-order to uniquely serialize a tree, not inorder (eg. [4,1,null,null,2] and [1,null,4,2,null] has the same inorder traversal)
        - eg. 297-Serialize and Deserialize Binary Tree; 572-Subtree of Another Tree; 652-Find Duplicate Subtrees
    - Tree height: 199-Binary Tree Right Side View; 366-Find Leaves of Binary Tree; 637-Average of Levels in Binary Tree(bfs and dfs); 655-Print Binary Tree; 1161-Maximum Level Sum of a Binary Tree
    - Tree balancing: 1382-Balance a Binary Search Tree (with sorting)
    - Tree path: 124-Binary Tree Maximum Path Sum; 298-Binary Tree Longest Consecutive Sequence|549-Binary Tree Longest Consecutive Sequence II; 543-Diameter of Binary Tree; 687-Longest Univalue Path; 1522-Diameter of N-Ary Tree

## TreeMap
- supported in Python using SortedDict (sorted map with O(logn) insertion/deletion)
```
from sortedcontainers import SortedDict
treemap = SortedDict({})
treemap.setdefault(x, [])
treemap[x].append(1)
treemap.peekitem(-1)[0] # peek largest key
treemap[x] # [1] get value
```
- eg: 716-Max Stack; 2034-Stock Price Fluctuation

## Trie
- when to use: Trie could use less space compared to hashmap when storing many keys with the same prefix (word search, spell checker, etc.)
- Trie data structure
```
class TrieNode:
    def __init__(self):
        self.isWord = False # mark word end
        self.children = collections.defaultdict(TrieNode)
```
- tips: use dfs to get all strings that start with the given prefix (can store whole sentence at the end node - eg.642)
- eg: 211-Design Add and Search Words Data Structure(basic); 139-Word Break|140-Word Break II; 616-Add Bold Tag in String; 642-Design Search Autocomplete System; 745-Prefix and Suffix Search(2 Tries);

## Union Find
- key word: connected group in a graph
- algorithm: union find by rank (assign node with higher rank as parent of a connected group)
- complexity: nlog(n) to union all n elements - see [this article](https://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/)
```
parents = [i for i in range(n)]
        
def find(x):
    if parents[x] != x:
        parents[x] = find(parents[x]) # recursion
    return parents[x]

# simple version: when only need to find pair-wise connection (don't need a universal parent for all items in a connected part)
def union(x, y):
    px, py = find(x), find(y)
    if px != py: # connect parents of x, y
        parents[px] = py

# todo: full verion - assign parents by rank (guarantees that all connected items have the same parent)

def isXandYConnected(n):
    if shouldConnectXandY(x, y):
        union(x, y)
    
    return find(x) == find(y) # bubble up to parents

```
- problem:
    - find connected groups: 128-Longest Consecutive Sequence; 305-Number of Islands II(hard); 323-Number of Connected Components in an Undirected Graph; 547-Number of Provinces; 721-Accounts Merge; 803-Bricks Falling When Hit (hard); 1722-Minimize Hamming Distance After Swap Operations (implicit); 952-Largest Component Size by Common Factor; 1562-Find Latest Group of Size M(hard); 1627-Graph Connectivity With Threshold | 1970-Last Day Where You Can Still Cross; 1998-GCD Sort of an Array; 2076-Process Restricted Friend Requests(hard)
    - cycle in graph: 261-Graph Valid Tree; 684-Redundant Connection
    - operation chaining: 399-Evaluate Division

## Other
- Account Balance: 465-Optimal Account Balancing (hashmap + backtracking)
- Deterministic Finite Automaton: 65-Valid Number

# Classic:
## Sums:
- Key words: 2 sum, 3 sum equal/smaller/closest to the target
- eg: 1, 167, 15, 259; 653-Two Sum IV - Input is a BST
- tips:
    hashmap or two-pointers
- variations:
    - running counter (with hashmap): 
        - key words: number of ways to get target sum/product
        - eg: 1577-Number of Ways Where Square of Number Is Equal to Product of Two Numbers

# Big O tips
- space
    - O(1): in-memory modification (eg.41-First Missing Positive)


# Needs revisit:
41-First Missing Positive
84-Largest Rectangle in Histogram
134-Gas Station
254-Factor Combinations
979-Distribute Coins in Binary Tree
1235-Maximum Profit in Job Scheduling (dp)
2040-Kth Smallest Product of Two Sorted Arrays
